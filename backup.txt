from fastapi import FastAPI, Request, Form, UploadFile, File, HTTPException, Path
from fastapi.responses import HTMLResponse, StreamingResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import datetime, timedelta
from bson import ObjectId
from gridfs import GridFSBucket
from io import BytesIO, StringIO
from pytz import timezone
import csv
import traceback

from .database import db, records_col
from .email_alert import send_email_alert
from .validators import validate_phone, validate_plate, validate_vin

app = FastAPI()
templates = Jinja2Templates(directory="app/templates")

async def log_action(action: str, record_id: str, changes: dict = None):
    """Store an audit log entry."""
    log_entry = {
        "action": action,  # e.g. "create", "update", "delete"
        "record_id": record_id,
        "timestamp": datetime.utcnow(),
        "changes": changes or {},
    }
    from .database import audit_col
    await audit_col.insert_one(log_entry)

async def check_expiring_insurances():
    print("üïê Running scheduled insurance check...")
    upcoming = datetime.utcnow() + timedelta(days=7)
    cursor = records_col.find({"insurance_end": {"$lte": upcoming}})
    items = await cursor.to_list(length=None)
    print(f"üîé Found {len(items)} expiring insurances")
    if items:
        send_email_alert(items)
        print("üìß Email alert sent")


# -------------------- STARTUP --------------------
@app.on_event("startup")
async def startup_event():
    # Create GridFS bucket
    app.state.fs_bucket = GridFSBucket(db.delegate)

    # Initialize scheduler with Bucharest timezone
    scheduler = AsyncIOScheduler(timezone=timezone("Europe/Bucharest"))
    scheduler.add_job(check_expiring_insurances, "cron", hour=7)
    scheduler.start()

    # ‚úÖ Save it for later use in /jobs
    app.state.scheduler = scheduler
    print("‚úÖ Scheduler started (Europe/Bucharest timezone)")


# -------------------- HOME PAGE --------------------
@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    cursor = records_col.find().sort("insurance_end", 1)
    data = await cursor.to_list(length=None)

    items = []
    for d in data:
        end = d.get("insurance_end")
        days_left = (end.date() - datetime.utcnow().date()).days if end else None
        items.append({
            "id": str(d["_id"]),
            "name": d.get("name"),
            "phone": d.get("phone"),
            "car_name": d.get("car_name"),
            "plate_number": d.get("plate_number"),
            "vin_number": d.get("vin_number"),
            "insurance_start": d.get("insurance_start").date() if d.get("insurance_start") else "",
            "insurance_end": end.date() if end else "",
            "days_left": days_left,
            "pdf_id": str(d["pdf_id"]) if d.get("pdf_id") else None,
        })
    return templates.TemplateResponse("index.html", {
        "request": request,
        "items": items,
        "today": datetime.utcnow().date()
    })


# -------------------- ADD RECORD --------------------
@app.post("/add")
async def add_record(
    name: str = Form(...),
    phone: str = Form(...),
    car_name: str = Form(...),
    plate_number: str = Form(...),
    vin_number: str = Form(...),
    insurance_start: str = Form(...),
    insurance_end: str = Form(...),
    pdf: UploadFile = File(None),
):
    # Validation
    validate_phone(phone)
    validate_plate(plate_number)
    validate_vin(vin_number)

    start_dt = datetime.strptime(insurance_start, "%Y-%m-%d")
    end_dt = datetime.strptime(insurance_end, "%Y-%m-%d")

    pdf_id = None
    if pdf and pdf.filename and pdf.content_type == "application/pdf":
        blob = await pdf.read()
        buffer = BytesIO(blob)

        pdf_id = app.state.fs_bucket.upload_from_stream(
            pdf.filename,
            buffer,
            metadata={"content_type": "application/pdf"}
        )

    doc = {
        "name": name.strip(),
        "phone": phone.strip(),
        "car_name": car_name.strip(),
        "plate_number": plate_number.strip(),
        "vin_number": vin_number.strip(),
        "insurance_start": start_dt,
        "insurance_end": end_dt,
        "pdf_id": pdf_id,
    }

    result = await records_col.insert_one(doc)
    await log_action("create", str(result.inserted_id), {"fields": list(doc.keys())})
    return RedirectResponse("/", status_code=303)



# -------------------- EXPORT SELECTED CSV --------------------
@app.post("/export_selected_csv")
async def export_selected_csv(selected_ids: str = Form(...)):
    ids = [ObjectId(i) for i in selected_ids.split(",") if i]
    cursor = records_col.find({"_id": {"$in": ids}})
    data = await cursor.to_list(length=None)

    out = StringIO()
    writer = csv.writer(out)
    writer.writerow(["Name", "Phone", "Car Name", "Plate Number", "VIN", "Start", "End"])
    for d in data:
        writer.writerow([
            d.get("name"), d.get("phone"), d.get("car_name"),
            d.get("plate_number"), d.get("vin_number"),
            d.get("insurance_start").date() if d.get("insurance_start") else "",
            d.get("insurance_end").date() if d.get("insurance_end") else "",
        ])
    out.seek(0)
    headers = {"Content-Disposition": 'attachment; filename="selected_insurances.csv"'}
    return StreamingResponse(iter([out.getvalue()]), media_type="text/csv", headers=headers)


# -------------------- DOWNLOAD PDF --------------------
@app.get("/download/{record_id}")
async def download_pdf(record_id: str):
    try:
        record = await records_col.find_one({"_id": ObjectId(record_id)})
        if not record or not record.get("pdf_id"):
            raise HTTPException(status_code=404, detail="PDF not found")

        pdf_id = record["pdf_id"]
        bucket = app.state.fs_bucket

        # ‚úÖ async GridFS download (non-blocking)
        buffer = BytesIO()
        file_id = pdf_id if isinstance(pdf_id, ObjectId) else ObjectId(pdf_id)
        bucket.download_to_stream(file_id, buffer)
        buffer.seek(0)

        headers = {
            "Content-Disposition": f'attachment; filename="{record.get("plate_number", "insurance")}.pdf"'
        }
        return StreamingResponse(buffer, media_type="application/pdf", headers=headers)

    except Exception as e:
        print("Download error:", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Error downloading PDF")

@app.get("/test_email")
async def test_email():
    await check_expiring_insurances()
    return {"message": "Email alert triggered manually!"}

@app.post("/delete/{record_id}")
async def delete_record(record_id: str):
    try:
        record = await records_col.find_one({"_id": ObjectId(record_id)})
        if not record:
            raise HTTPException(status_code=404, detail="Record not found")

        await records_col.delete_one({"_id": ObjectId(record_id)})
        await log_action("delete", record_id, {"deleted_record": record.get("name")})
        return RedirectResponse("/", status_code=303)
    except Exception as e:
        print("Delete error:", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error deleting record: {e}")

    
@app.get("/edit/{record_id}", response_class=HTMLResponse)
async def edit_record(request: Request, record_id: str = Path(...)):
    record = await records_col.find_one({"_id": ObjectId(record_id)})
    if not record:
        raise HTTPException(status_code=404, detail="Record not found")

    record_data = {
        "id": str(record["_id"]),
        "name": record.get("name", ""),
        "phone": record.get("phone", ""),
        "car_name": record.get("car_name", ""),
        "plate_number": record.get("plate_number", ""),
        "vin_number": record.get("vin_number", ""),
        "insurance_start": record.get("insurance_start").strftime("%Y-%m-%d") if record.get("insurance_start") else "",
        "insurance_end": record.get("insurance_end").strftime("%Y-%m-%d") if record.get("insurance_end") else "",
    }

    return templates.TemplateResponse("edit.html", {"request": request, "record": record_data})
    
@app.get("/jobs")
async def list_jobs():
    scheduler = getattr(app.state, "scheduler", None)
    if not scheduler:
        raise HTTPException(status_code=500, detail="Scheduler not initialized")

    jobs = scheduler.get_jobs()
    return [{"id": j.id, "next_run": str(j.next_run_time)} for j in jobs]

@app.post("/update/{record_id}")
async def update_record(
    record_id: str,
    name: str = Form(...),
    phone: str = Form(...),
    car_name: str = Form(...),
    plate_number: str = Form(...),
    vin_number: str = Form(...),
    insurance_start: str = Form(...),
    insurance_end: str = Form(...),
    pdf: UploadFile = File(None),
):
    try:
        # Validate data
        validate_phone(phone)
        validate_plate(plate_number)
        validate_vin(vin_number)

        start_dt = datetime.strptime(insurance_start, "%Y-%m-%d")
        end_dt = datetime.strptime(insurance_end, "%Y-%m-%d")

        update_data = {
            "name": name.strip(),
            "phone": phone.strip(),
            "car_name": car_name.strip(),
            "plate_number": plate_number.strip(),
            "vin_number": vin_number.strip(),
            "insurance_start": start_dt,
            "insurance_end": end_dt,
        }

        # If user uploaded a new PDF
        if pdf and pdf.filename and pdf.content_type == "application/pdf":
            blob = await pdf.read()
            bucket = app.state.fs_bucket
            stream = BytesIO(blob)
            pdf_id = await bucket.upload_from_stream(pdf.filename, stream)

            # Delete old PDF (optional but clean)
            old_record = await records_col.find_one({"_id": ObjectId(record_id)})
            if old_record and old_record.get("pdf_id"):
                try:
                    await bucket.delete(ObjectId(old_record["pdf_id"]))
                except Exception as e:
                    print("‚ö†Ô∏è Warning: failed to delete old PDF:", e)

            update_data["pdf_id"] = pdf_id

        result = await records_col.update_one(
            {"_id": ObjectId(record_id)}, {"$set": update_data}
        )

        if result.modified_count == 0:
            raise HTTPException(status_code=404, detail="Record not found or no changes made")

        # Audit log
        await app.state.audit_col.insert_one({
            "action": "update",
            "record_id": record_id,
            "timestamp": datetime.utcnow(),
            "changes": update_data,
        })

        return RedirectResponse("/", status_code=303)

    except Exception as e:
        print("‚ùå Error updating record:", e)
        raise HTTPException(status_code=500, detail=f"Error updating record: {e}")

    
@app.get("/logs", response_class=HTMLResponse)
async def view_logs(request: Request):
        from .database import audit_col
        cursor = audit_col.find().sort("timestamp", -1)
        logs = await cursor.to_list(length=100)

        formatted = []
        for l in logs:
            formatted.append({
                "time": l["timestamp"].strftime("%Y-%m-%d %H:%M:%S"),
                "action": l["action"],
                "record_id": l.get("record_id", ""),
                "changes": l.get("changes", {}),
            })
        return templates.TemplateResponse("logs.html", {"request": request, "logs": formatted})